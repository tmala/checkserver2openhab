/**
 * Get server-status and reports to an item at openHAB
 */
importScripts = require('./importscripts.js').importScripts;
importScripts('./settings.ns');
importScripts('./myLogger.ns');
let XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;
const NAME_LENGTH = 18;

setCurrentLogLevel(LOGLEVEL_DEBUG);

if (isInfo()) {
    console.log(ts() + " Starting CheckServer2openHAB");
}

const DELAY_BETWEEN_CALLS = 5*1000; // 5 seconds

let serverStatusMessage = '';

serverStatusMessage = 'Updating serverstatus ' + ts();
sendCommand(OPENHAB_ITEM_ServerStatus, serverStatusMessage);

// Run Every Hour after first run if parameter 'forever' is present
let runForEver = false;
process.argv.forEach(function (val, index, array) {
    if ('forever' === val) {
        runForEver = true;
    }
});

setTimeout(() => {
    runUpdate();
    if (runForEver) {
        setInterval(() => {
            runUpdate();
        }, 60 * 60 * 1000);
    }
}, 1000);

function runUpdate() {
    const os = require('os');
    const ip = require('ip');
    const bytes = require('bytes');
    const util = require('util');
    // First some Basic Info about this server
    serverStatusMessage = '';
    serverStatusMessage += '\n' + addPad('Hostname') + os.hostname();
    serverStatusMessage += '\n' + addPad('IP-Address') + ip.address();
    serverStatusMessage += '\n' + addPad('OS') + os.type() +' ' + os.platform() + ' ' + os.arch() + ' ' + os.release();
    const upTime = seconds2json(os.uptime);
    serverStatusMessage += '\n' + addPad('UpTime') + upTime.days + ' days, ' + fix2digit(upTime.hours) + ':' + fix2digit(upTime.minutes) + ':' + fix2digit(upTime.seconds);
    serverStatusMessage += '\n' + addPad('Load') + os.loadavg();
    serverStatusMessage += '\n' + addPad('Memory') + bytes.format(os.totalmem()) + ',  ' + bytes.format(os.freemem()) + ' free';
    // Check some local running processes
    serverStatusMessage += '\n' + addPad(S1_NAME) + checkProcess(S1_PIDFILE, S1_PROCESS);
    serverStatusMessage += '\n' + addPad(S2_NAME) + checkProcess(S2_PIDFILE, S2_PROCESS);
    serverStatusMessage += '\n' + addPad(S3_NAME) + checkProcess(S3_PIDFILE, S3_PROCESS);

    // Send the data to openHAB
    setTimeout(
        function() {
            const tmpMsg = addPad('LastRun') + ts() + serverStatusMessage;
            sendCommand(OPENHAB_ITEM_ServerStatus, tmpMsg);
            if (isInfo()) {
                console.log(ts() + ' openHAB item: ' + OPENHAB_ITEM_ServerStatus + ' updated');
            }
            },
        DELAY_BETWEEN_CALLS);
}

function addPad(s) {
    let ret = '';
    ret += s;

    ret += '.'.repeat(NAME_LENGTH - s.length);
    ret += ': ';
    return ret;
}

/**
 * Checks that the process with PID given in the pidFile is running
 * Returns a String telling the status of the process
 *
 * @param pidFileName
 * @param processName
 */
function checkProcess(pidFileName, processName) {
    let fs = require('fs');
    if (fs.existsSync(pidFileName)) {
        let myPid = fs.readFileSync(pidFileName, 'utf8');
        if ( !myPid || myPid.trim().length<=1 ) {
            return 'No such PID-file found';
        }
        myPid = myPid.trim();

        // Handle FR24FEED specially
        if (myPid === 'fr24feed') {
            return checkFR24Feed(processName);
        } else {
            const childProcess = require('child_process');
            const myCmd = 'ps -ef | grep "' + processName + '" | grep ' + myPid +  ' | grep -v grep';
            if (isDebug()) {
                console.log('Getting PID: ' + myPid + ' from pidfile: ' + pidFileName);
                console.log('Checking result from command: ' + myCmd);
            }
            let stdout;
            try {
                stdout = childProcess.execSync(myCmd);
                if (stdout && stdout.length>0) {
                    return 'Process ' + processName +  ' is running with PID=' + myPid;
                } else {
                    return 'No such process is running';
                }
            } catch (ex) {
                if (isError() ) {
                    console.log(ts() + ' ERROR ??? ' + ex.stdout);
                }
                return 'No such process is running';
            }
        }
    } else {
        return 'PID-file does not exist';
    }
}

function checkFR24Feed(myCmd) {
    const childProcess = require('child_process');
    if (isDebug()) {
        console.log('Checking result from command: ' + myCmd);
    }
    let stdout;
    try {
        stdout = childProcess.execSync(myCmd);
        if (stdout && stdout.length>0) {
            let tmpStr = '' + stdout;
            let ret = '';
            let lines = tmpStr.val().split('\n');
            for(let i = 0; i < lines.length; i++){
                ret = '\n' + ' '.repeat(NAME_LENGTH + 2) + lines[i];
            }
            return ret;
        } else {
            return ' Unable to check using ' + myCmd;
        }
    } catch (ex) {
        if (isError() ) {
            console.log(ts() + ' ERROR ??? ' + myCmd);
        }
        return 'No output from ' + myCmd;
    }
}




/**
 * Sends a command to update an openHAB Item
 *
 * @param itemId
 * @param command
 */
function sendCommand(itemId, command) {
    let xhr_sendCommand = new XMLHttpRequest();
    xhr_sendCommand.withCredentials = true;
    xhr_sendCommand.addEventListener("readystatechange", function () {
        if (this.readyState === this.DONE) {
            if (this.status === 200) {
                let res = this.responseText;
                if (isTrace()) {
                    console.log(ts() + " " + this.status +  " OK => Response: ", res);
                }
            } else {
                let res = this.responseText;
                if (isError()) {
                    console.log(ts() + " " + this.status +  " " + this.statusText + " => Response: ", JSON.stringify(res, null, 2) );
                }
            }
        }
    });
    xhr_sendCommand.open('POST', OPENHAB_URL + itemId);
    xhr_sendCommand.setRequestHeader("accept", "application/json");
    xhr_sendCommand.send(command);
}

/***********************************************************
 * Some DATETIME-related functions
 ***********************************************************
 */
function ts() {
    let d = new Date();
    return date2str_NO(d);
}
function date2str_NO(d) {
    return fix2digit(d.getDate()) + '.' + fixMonth(d.getMonth()) + '.' + d.getFullYear() + ' ' +
        fix2digit(d.getHours()) + ':' + fix2digit(d.getMinutes()) + ':' + fix2digit(d.getSeconds());
}
function fixMonth(num) {
    let month = num + 1;
    if (month < 10) {
        return '0' + month;
    } else {
        return '' + month;
    }
}
function fix2digit(num) {
    if (num < 10) {
        return '0' + num;
    } else {
        return '' + num;
    }
}
function seconds2json(seconds) {
    let d, h, m, s;

    if (isNaN(seconds)) {
        throw new TypeError('Value sent to seconds-converter must be a number.');
    }

    m = Math.floor(seconds / 60);
    s = seconds % 60;
    h = Math.floor(m / 60);
    m = m % 60;
    d = Math.floor(h / 24);
    h = h % 24;

    return {days: d, hours: h, minutes: m, seconds: s}
}


